#!/usr/bin/env bash
#
# fff - fucking fast file-manager. (original)
# ffff - fork fucking fast file-manager.

# Global variable for repeat count
repeat_count=""
history_full_list=()
history_mode=0

get_os() {
    # Figure out the current operating system to set some specific variables.
    # '$OSTYPE' typically stores the name of the OS kernel.
    case $OSTYPE in
        # Mac OS X / macOS.
        darwin*)
            opener=open
            file_flags=bIL
        ;;

        haiku)
            opener=open

            [[ -z $FFF_TRASH_CMD ]] &&
                FFF_TRASH_CMD=trash

            [[ $FFF_TRASH_CMD == trash ]] && {
                FFF_TRASH=$(finddir -v "$PWD" B_TRASH_DIRECTORY)
                mkdir -p "$FFF_TRASH"
            }
        ;;
    esac
}

setup_terminal() {
    # Setup the terminal for the TUI.
    # '\e[?1049h': Use alternative screen buffer.
    # '\e[?7l':    Disable line wrapping.
    # '\e[?25l':   Hide the cursor.
    # '\e[2J':     Clear the screen.
    # '\e[1;Nr':   Limit scrolling to scrolling area.
    #              Also sets cursor to (0,0).
    printf '\e[?1049h\e[?7l\e[?25l\e[2J\e[1;%sr' "$max_items"

    # Hide echoing of user input
    stty -echo
}

reset_terminal() {
    # Reset the terminal to a useable state (undo all changes).
    # '\e[?7h':   Re-enable line wrapping.
    # '\e[?25h':  Unhide the cursor.
    # '\e[2J':    Clear the terminal.
    # '\e[;r':    Set the scroll region to its default value.
    #             Also sets cursor to (0,0).
    # '\e[?1049l: Restore main screen buffer.
    printf '\e[?7h\e[?25h\e[2J\e[;r\e[?1049l'

    # Show user input.
    stty echo
}

clear_screen() {
    # Only clear the scrolling window (dir item list).
    # '\e[%sH':    Move cursor to bottom of scroll area.
    # '\e[9999C':  Move cursor to right edge of the terminal.
    # '\e[1J':     Clear screen to top left corner (from cursor up).
    # '\e[2J':     Clear screen fully (if using tmux) (fixes clear issues).
    # '\e[1;%sr':  Clearing the screen resets the scroll region(?). Re-set it.
    #              Also sets cursor to (0,0).
    printf '\e[%sH\e[9999C\e[1J%b\e[1;%sr' \
           "$((LINES-2))" "${TMUX:+\e[2J}" "$max_items"
}

setup_options() {
    # Some options require some setup.
    # This function is called once on open to parse
    # select options so the operation isn't repeated
    # multiple times in the code.

    # Format for normal files.
    [[ $FFF_FILE_FORMAT == *%f* ]] && {
        file_pre=${FFF_FILE_FORMAT/'%f'*}
        file_post=${FFF_FILE_FORMAT/*'%f'}
    }

    # Format for marked files.
    # Use affixes provided by the user or use defaults, if necessary.
    if [[ $FFF_MARK_FORMAT == *%f* ]]; then
        mark_pre=${FFF_MARK_FORMAT/'%f'*}
        mark_post=${FFF_MARK_FORMAT/*'%f'}
    else
        mark_pre=" "
        mark_post="*"
    fi

    # Find supported 'file' arguments.
    file -I &>/dev/null || : "${file_flags:=biL}"
}

get_term_size() {
    # Get terminal size ('stty' is POSIX and always available).
    # This can't be done reliably across all bash versions in pure bash.
    read -r LINES COLUMNS < <(stty size)

    # Max list items that fit in the scroll area.
    ((max_items=LINES-3))
}

get_ls_colors() {
    # Parse the LS_COLORS variable and declare each file type
    # as a separate variable.
    # Format: ':.ext=0;0:*.jpg=0;0;0:*png=0;0;0;0:'
    [[ -z $LS_COLORS ]] && {
        FFF_LS_COLORS=0
        return
    }

    # Turn $LS_COLORS into an array.
    IFS=: read -ra ls_cols <<< "$LS_COLORS"

    for ((i=0;i<${#ls_cols[@]};i++)); {
        # Separate patterns from file types.
        [[ ${ls_cols[i]} =~ ^\*[^\.] ]] &&
            ls_patterns+="${ls_cols[i]/=*}|"

        # Prepend 'ls_' to all LS_COLORS items
        # if they aren't types of files (symbolic links, block files etc.)
        [[ ${ls_cols[i]} =~ ^(\*|\.) ]] && {
            ls_cols[i]=${ls_cols[i]#\*}
            ls_cols[i]=ls_${ls_cols[i]#.}
        }
    }

    # Strip non-ascii characters from the string as they're
    # used as a key to color the dir items and variable
    # names in bash must be '[a-zA-z0-9_]'.
    ls_cols=("${ls_cols[@]//[^a-zA-Z0-9=\\;]/_}")

    # Store the patterns in a '|' separated string
    # for use in a REGEX match later.
    ls_patterns=${ls_patterns//\*}
    ls_patterns=${ls_patterns%?}

    # Define the ls_ variables.
    # 'declare' can't be used here as variables are scoped
    # locally. 'declare -g' is not available in 'bash 3'.
    # 'export' is a viable alternative.
    export "${ls_cols[@]}" &>/dev/null
}

get_mime_type() {
    # Get a file's mime_type.
    mime_type=$(file "-${file_flags:-biL}" "$1" 2>/dev/null)
}

status_line() {
    # Draw the status line at the bottom of the terminal.
    # It shows the current scroll position, any marked files, current directory and history mode.

    # If the current working window is '.bash_history directory list', it shows the number of entries in the history.
    if ((history_mode == 1)); then
        local mark_ui=""
        # '${1:-...}':               If a first argument is passed, use it as `status_text`.
        #                            Otherwise, fall back to using the current working directory (`$PWD`).
        # '$'\e[37;40m ... \e[0m'':  ANSI escape string for terminal coloring.
        # '\e[37;40m':               Set text color to white (37) on black background (40).
        # '.bash_h....index':        Displayed fallback text.
        # '${PWD//[^[:print:]]/^[}': Replace all non-printable characters in `$PWD`
        #                            with the literal string `^[` (often used to indicate control characters).
        #                            This ensures `status_text` is safe for display in terminals.
        local status_text="${1:-$'\e[37;40m .bash_history directory index ('${PWD//[^[:print:]]/^[}$') '}"
    else
        local mark_ui="[${#marked_files[@]}] selected (${file_program[*]}) [p] ->"
        # Use current PWD
        local status_text="${1:-${PWD//[^[:print:]]/^[}}"
    fi

    # Escape the directory string.
    # Remove all non-printable characters.
    PWD_escaped=${PWD//[^[:print:]]/^[}

    # '\e7':       Save cursor position.
    #              This is more widely supported than '\e[s'.
    # '\e[%sH':    Move cursor to bottom of the terminal.
    # '\e[30;47m': Set foreground and background colors.
    # '%*s':       Insert enough spaces to fill the screen width.
    #              This sets the background color to the whole line
    #              and fixes issues in 'screen' where '\e[K' doesn't work.
    # '\r':        Move cursor back to column 0 (was at EOL due to above).
    # '\e[m':      Reset text formatting.
    # '\e[H\e[K':  Clear line below status_line.
    # '\e8':       Restore cursor position.
    #              This is more widely supported than '\e[u'.
    printf '\e7\e[%sH\e[3%s;4%sm%*s\r%s %s%s\e[m\e[%sH\e[K\e8' \
           "$((LINES-1))" \
           "${FFF_COL5:-0}" \
           "${FFF_COL2:-7}" \
           "$COLUMNS" "" \
           "($((scroll+1))/$((list_total+1)))" \
           "${marked_files[*]:+${mark_ui}}" \
           "$status_text" \
           "$LINES"
}

read_dir() {
    # Read a directory to an array and sort it directories first.
    local dirs
    local files
    local item_index

    # Set window name.
    printf '\e]2;fff: %s\e'\\ "$PWD"

    # If '$PWD' is '/', unset it to avoid '//'.
    [[ $PWD == / ]] && PWD=

    for item in "$PWD"/*; do
        if [[ -d $item ]]; then
            dirs+=("$item")

            # Find the position of the child directory in the
            # parent directory list.
            [[ $item == "$OLDPWD" ]] &&
                ((previous_index=item_index))
            ((item_index++))
        else
            files+=("$item")
        fi
    done

    list=("${dirs[@]}" "${files[@]}")

    # Indicate that the directory is empty.
    [[ -z ${list[0]} ]] &&
        list[0]=empty

    ((list_total=${#list[@]}-1))

    # Save the original dir in a second list as a backup.
    cur_list=("${list[@]}")
}

print_line() {
    # Format the list item and print it.

    # History mode checking
    if ((history_mode == 1)); then
        # History mode: show full history entry
        local file_name="${list[$1]}"
    else
        # Normal mode
        local file_name="${list[$1]##*/}"
    fi

    local file_ext=${file_name##*.}
    local format
    local suffix

    # If the dir item doesn't exist, end here.
    if [[ -z ${list[$1]} ]]; then
        return

    # Directory.
    elif [[ -d ${list[$1]} ]]; then
        format+=\\e[${di:-1;3${FFF_COL1:-2}}m
        suffix+=/

    # Block special file.
    elif [[ -b ${list[$1]} ]]; then
        format+=\\e[${bd:-40;33;01}m

    # Character special file.
    elif [[ -c ${list[$1]} ]]; then
        format+=\\e[${cd:-40;33;01}m

    # Executable file.
    elif [[ -x ${list[$1]} ]]; then
        format+=\\e[${ex:-01;32}m

    # Symbolic Link (broken).
    elif [[ -h ${list[$1]} && ! -e ${list[$1]} ]]; then
        format+=\\e[${mi:-01;31;7}m

    # Symbolic Link.
    elif [[ -h ${list[$1]} ]]; then
        format+=\\e[${ln:-01;36}m

    # Fifo file.
    elif [[ -p ${list[$1]} ]]; then
        format+=\\e[${pi:-40;33}m

    # Socket file.
    elif [[ -S ${list[$1]} ]]; then
        format+=\\e[${so:-01;35}m

    # Color files that end in a pattern as defined in LS_COLORS.
    # 'BASH_REMATCH' is an array that stores each REGEX match.
    elif [[ $FFF_LS_COLORS == 1 &&
            $ls_patterns &&
            $file_name =~ ($ls_patterns)$ ]]; then
        match=${BASH_REMATCH[0]}
        file_ext=ls_${match//[^a-zA-Z0-9=\\;]/_}
        format+=\\e[${!file_ext:-${fi:-37}}m

    # Color files based on file extension and LS_COLORS.
    # Check if file extension adheres to POSIX naming
    # standard before checking if it's a variable.
    elif [[ $FFF_LS_COLORS == 1 &&
            $file_ext != "$file_name" &&
            $file_ext =~ ^[a-zA-Z0-9_]*$ ]]; then
        file_ext=ls_${file_ext}
        format+=\\e[${!file_ext:-${fi:-37}}m

    else
        format+=\\e[${fi:-37}m
    fi

    # If the list item is under the cursor.
    (($1 == scroll)) &&
        format+="\\e[1;3${FFF_COL4:-7};7m"

    # If the list item is marked for operation.
    [[ ${marked_files[$1]} == "${list[$1]:-null}" ]] && {
        format+=\\e[3${FFF_COL3:-1}m${mark_pre}
        suffix+=${mark_post}
    }

    # Escape the directory string.
    # Remove all non-printable characters.
    file_name=${file_name//[^[:print:]]/^[}

    # Calculate relative line number (like Vim)
    local lineno
    if (($1 == scroll)); then
        # Current line shows absolute line number
        lineno=$(( $1 + 1 ))
    else
        # Other lines show relative distance from cursor
        lineno=$(( $1 > scroll ? $1 - scroll : scroll - $1 ))
    fi
    
    # 5-space padding without displaying the line numbers
    # \r          Return cursor to the beginning of the line (carriage return)
    # \e[0;37;0m  Start gray bold text (ANSI: reset + light gray + normal)
    # %5s         Print a 5-character-wide blank space (placeholder for line number)
    # \e[m        Reset text style to default
    # %b          Print formatted file prefix and format string (may contain ANSI codes)
    # %s          Print the final part: file name + optional suffix + optional postfix
    # \e[m        Reset text style again (in case %b or %s included formatting)
    # \r          Ensure cursor stays at the start of the line after printing
    printf '\r\e[0;37;0m%5s\e[m %b%s\e[m\r' \
        "" \
        "${file_pre}${format}" \
        "${file_name}${suffix}${file_post}"
}

redraw_numbers() {
    # Redraw only the line number column (first 5 characters per line)
    # This function is for performance by skipping full redraws.

    # Save the current cursor position so we can restore it later
    printf '\e7'

    # Move the cursor to the top of the scrollable area (screen start)
    printf '\e[H'

    # Determine the visible range of items
    # `scroll` is the current cursor line (0-based index)
    # `y` is the cursor position in the visible window
    local scroll_start=$((scroll - y + 1))  # First visible line index
    ((scroll_start < 0)) && scroll_start=1  # Clamp to 1 to avoid negative values

    local scroll_end=$((scroll_start + max_items))  # Last visible line index (exclusive)
    ((scroll_end >= list_total)) && scroll_end=$((list_total + 1))  # Clamp to end of list

    # Maximum number of lines to visually render (limit relative line number logic)
    local max_display_lines=300

    # Draw each visible line number
    for ((i = scroll_start; i < scroll_end; i++)); do
        # Only print newline after the first line to avoid extra blank line at top
        ((i > scroll_start)) && printf '\n'

        # Compute distance from the currently selected item (cursor)
        local dist=$((i > scroll ? i - scroll : scroll - i))

        # Skip if this item is too far from the current cursor (off-screen optimization)
        ((dist > max_display_lines)) && continue

        # Determine line number to display:
        # - Show absolute line number on the current line (under cursor)
        # - Show relative line numbers on others
        local lineno
        if ((i == scroll)); then
            lineno=$((i + 1))  # Absolute line number (1-based)
        else
            lineno=$dist       # Relative distance from cursor
        fi

        # Pad the number to exactly 5 characters + 1 space (e.g., "    5 ", "  123 ")
        printf -v lineno "%5d " "$lineno"

        # Highlight the current line with bold white text and inverse background
        # \e[1;37;7m    bold (1), white text (37), reverse video (7: swaps fg/bg)
        # \e[m          reset text style
        # \e[90m        gray text for other lines
        # \e[0m         reset text style again
        ((i == scroll)) && printf '\e[1;3%s;7m%s\e[m' "${FFF_COL4:-7}" "$lineno" || printf '\e[90m%s\e[m' "$lineno"
    done

    # Restore the cursor to the previously saved position
    printf '\e8'
}

draw_dir() {
    # Print the max directory items that fit in the scroll area.

    local scroll_start=$scroll
    local scroll_new_pos
    local scroll_end

    # When going up the directory tree, place the cursor on the position
    # of the previous directory.
    ((find_previous == 1)) && {
        ((scroll_start=previous_index))
        ((scroll=scroll_start))

        # Clear the directory history. We're here now.
        find_previous=
    }

    # If current dir is near the top of the list, keep scroll position.
    if ((list_total < max_items || scroll < max_items/2)); then
        ((scroll_start=0))
        ((scroll_end=max_items))
        ((scroll_new_pos=scroll+1))

    # If current dir is near the end of the list, keep scroll position.
    elif ((list_total - scroll < max_items/2)); then
        ((scroll_start=list_total-max_items+1))
        ((scroll_new_pos=max_items-(list_total-scroll)))
        ((scroll_end=list_total+1))

    # If current dir is somewhere in the middle, center scroll position.
    else
        ((scroll_start=scroll-max_items/2))
        ((scroll_end=scroll_start+max_items))
        ((scroll_new_pos=max_items/2+1))
    fi

    # Reset cursor position.
    printf '\e[H'

    for ((i=scroll_start;i<scroll_end;i++)); {
        # Don't print one too many newlines.
        ((i > scroll_start)) &&
            printf '\n'

        print_line "$i"
    }

    # Move the cursor to its new position if it changed.
    # If the variable 'scroll_new_pos' is empty, the cursor
    # is moved to line '0'.
    printf '\e[%sH' "$scroll_new_pos"
    ((y=scroll_new_pos))
    redraw_numbers
}

show_history() {
    # Show the history of .bash_history

    # Save current state
    saved_list=("${list[@]}")
    saved_cur_list=("${cur_list[@]}")
    saved_scroll=$scroll
    saved_list_total=$list_total
    saved_PWD=$PWD
    saved_marked_files=("${marked_files[@]}")
    saved_search=$search
    saved_history_mode=$history_mode

    # Get unique history entries (most recent first)
    history_list=()
    while IFS= read -r line; do
        history_list+=("$line")
    done < <(grep -E '^cd (/|/mnt/|/[a-zA-Z]/|[a-zA-Z]:\\)' ~/.bash_history | awk '!seen[$0]++' | tac)


    if ((${#history_list[@]} == 0)); then
        history_list=("No history found")
    fi

    # Store full history for searching
    history_full_list=("${history_list[@]}")

    # Setup history mode
    list=("${history_list[@]}")
    cur_list=("${history_list[@]}")
    scroll=0
    list_total=${#history_list[@]}-1
    PWD="HISTORY"
    marked_files=()
    search=
    history_mode=1
    redraw
}

draw_img() {
    # Draw an image file on the screen using chafa.

    [[ -f "${list[scroll]}" ]] || return
    get_mime_type "${list[scroll]}"
    [[ $mime_type != image/* ]] && return
    # chafa isn't installed, do nothing.
    type -p chafa &>/dev/null || {
        cmd_line "error: Couldn't find 'chafa', is it installed?"
        return
    }
    clear_screen
    # Initialize the image index
    img_index=$scroll
    while true; do
        # Clear the screen before displaying the image.
        clear_screen

        # Get terminal height and apply 98% scaling
        term_width=$(tput cols)
        term_height=$(tput lines)
        max_height=$(( term_height * 95 / 100 ))

        # Display the image with limited height
        chafa -d 0 --size="${term_width}x${max_height}" --scale=max "${list[img_index]}"

        # Update the global scroll variable
        scroll=$img_index
        # Use status_line to display information
        status_line "${list[img_index]}"
        # Wait for user input.
        read -ern 1 key
        case "$key" in
            j)
                # Move to the next image
                ((img_index < list_total)) && ((img_index++))
                ;;
            k)
                # Move to the previous image
                ((img_index > 0)) && ((img_index--))
                ;;
            *)
                # Exit the image viewer
                break
                ;;
        esac
    done
    # Reset the scroll position to the current image index
    scroll=$img_index
    setup_terminal
    redraw
}

redraw() {
    # Redraw the current window.
    # If 'full' is passed, re-fetch the directory list.
    [[ $1 == full ]] && {
        read_dir
        scroll=0
    }

    clear_screen
    draw_dir
    status_line
}

mark() {
    # Mark file for operation.
    # If an item is marked in a second directory,
    # clear the marked files.
    [[ $PWD != "$mark_dir" ]] &&
        marked_files=()

    # Don't allow the user to mark the empty directory list item.
    [[ ${list[0]} == empty && -z ${list[1]} ]] &&
        return

    if [[ $1 == all ]]; then
        if ((${#marked_files[@]} != ${#list[@]})); then
            marked_files=("${list[@]}")
            mark_dir=$PWD
        else
            marked_files=()
        fi

        redraw
    else
        if [[ ${marked_files[$1]} == "${list[$1]}" ]]; then
            unset 'marked_files[scroll]'

        else
            marked_files[$1]="${list[$1]}"
            mark_dir=$PWD
        fi

        # Clear line before changing it.
        printf '\e[K'
        print_line "$1"
    fi

    # Find the program to use.
    case "$2" in
        ${FFF_KEY_YANK:=y}|${FFF_KEY_YANK_ALL:=Y}) file_program=(cp -iR) ;;
        ${FFF_KEY_MOVE:=m}|${FFF_KEY_MOVE_ALL:=M}) file_program=(mv -i)  ;;
        ${FFF_KEY_LINK:=s}|${FFF_KEY_LINK_ALL:=S}) file_program=(ln -s)  ;;

        # These are 'fff' functions.
        ${FFF_KEY_TRASH:=d}|${FFF_KEY_TRASH_ALL:=D})
            file_program=(trash)
        ;;

        ${FFF_KEY_BULK_RENAME:=b}|${FFF_KEY_BULK_RENAME_ALL:=B})
            file_program=(bulk_rename)
        ;;
    esac

    status_line
}

trash() {
    # Trash a file.
    cmd_line "trash [${#marked_files[@]}] items? [y/n]: " y n

    [[ $cmd_reply != y ]] &&
        return

    if [[ $FFF_TRASH_CMD ]]; then
        # Pass all but the last argument to the user's
        # custom script. command is used to prevent this function
        # from conflicting with commands named "trash".
        command "$FFF_TRASH_CMD" "${@:1:$#-1}"

    else
        cd "$FFF_TRASH" || cmd_line "error: Can't cd to trash directory."

        if cp -alf "$@" &>/dev/null; then
            rm -r "${@:1:$#-1}"
        else
            mv -f "$@"
        fi

        # Go back to where we were.
        cd "$OLDPWD" ||:
    fi
}

bulk_rename() {
    # Bulk rename files using '$EDITOR'.
    rename_file=${XDG_CACHE_HOME:=${HOME}/.cache}/fff/bulk_rename
    marked_files=("${@:1:$#-1}")

    # Save marked files to a file and open them for editing.
    printf '%s\n' "${marked_files[@]##*/}" > "$rename_file"
    "${EDITOR:-vi}" "$rename_file"

    # Read the renamed files to an array.
    IFS=$'\n' read -d "" -ra changed_files < "$rename_file"

    # If the user deleted a line, stop here.
    ((${#marked_files[@]} != ${#changed_files[@]})) && {
        rm "$rename_file"
        cmd_line "error: Line mismatch in rename file. Doing nothing."
        return
    }

    printf '%s\n%s\n' \
        "# This file will be executed when the editor is closed." \
        "# Clear the file to abort." > "$rename_file"

    # Construct the rename commands.
    for ((i=0;i<${#marked_files[@]};i++)); {
        [[ ${marked_files[i]} != "${PWD}/${changed_files[i]}" ]] && {
            printf 'mv -i -- %q %q\n' \
                "${marked_files[i]}" "${PWD}/${changed_files[i]}"
            local renamed=1
        }
    } >> "$rename_file"

    # Let the user double-check the commands and execute them.
    ((renamed == 1)) && {
        "${EDITOR:-vi}" "$rename_file"

        source "$rename_file"
        rm "$rename_file"
    }

    # Fix terminal settings after '$EDITOR'.
    setup_terminal
}

open() {
    # Open directories and files.

    if [[ $PWD == "HISTORY" ]]; then
        # Extract directory from history line
        local selected_dir="${list[scroll]#cd }"
        
        # Restore previous state
        list=("${saved_list[@]}")
        cur_list=("${saved_cur_list[@]}")
        scroll=$saved_scroll
        list_total=$saved_list_total
        PWD=$saved_PWD
        marked_files=("${saved_marked_files[@]}")
        search=$saved_search
        history_mode=$saved_history_mode

        # Change to selected directory
        cd "$selected_dir" 2>/dev/null || {
            cmd_line "error: Cannot access '$selected_dir'"
            redraw
            return
        }
        
        redraw full
        # RESTORE HISTORY MODE FLAG
        history_mode=0
    # Open directories and files.
    elif [[ -d "$1"/ ]]; then
        search=
        search_end_early=
        cd "${1:-/}" ||:
        redraw full
    elif [[ -f "$1" ]]; then
        # Figure out what kind of file we're working with.
        get_mime_type "$1"
        # Get the file extension
        file_extension="${1##*.}"
        
        # Determine the operating system
        case "$(uname -s)" in
            Linux*)     os=Linux;;
            Darwin*)    os=Mac;;
            CYGWIN*)    os=Windows;;
            MINGW*)     os=Windows;;
            *)          os=Unknown;;
        esac
        
        # Convert path if necessary
        if [[ $os == "Windows" ]]; then
            file_path=$(cygpath -w "$1")
        else
            file_path="$1"
        fi
        
        case "$mime_type" in
            # 'start' is used to open files with their default applications on WIndows.
            # 'open':   Open a file in the default application on Mac.
            text/*|*x-empty*|*json*)
                # Text files handling
                ((file_picker == 1)) && {
                    printf '%s\n' "$1" > \
                        "${XDG_CACHE_HOME:=${HOME}/.cache}/fff/opened_file"
                    exit
                }
                clear_screen
                reset_terminal
                # Open all text-based files in '$EDITOR'.
                "${VISUAL:-${EDITOR:-}}" "$file_path"
                setup_terminal
                redraw
            ;;
            audio/*|video/*)
                if [[ $os == "Windows" ]]; then
                    start "" "$file_path"
                elif [[ $os == "Mac" ]]; then
                    open "$file_path" &>/dev/null &
                else
                    nohup xdg-open "$file_path" &>/dev/null &
                    disown
                fi
            ;;
            application/pdf)
                if [[ $os == "Windows" ]]; then
                    start "" "$file_path"
                elif [[ $os == "Mac" ]]; then
                    open "$file_path" &>/dev/null &
                else
                    nohup xdg-open "$file_path" &>/dev/null &
                    disown
                fi
            ;;
            application/msword|application/vnd.openxmlformats-officedocument.wordprocessingml.*)
                if [[ $os == "Windows" ]]; then
                    start winword "$file_path"
                elif [[ $os == "Mac" ]]; then
                    open -a "Microsoft Word" "$file_path" &>/dev/null &
                else
                    nohup xdg-open "$file_path" &>/dev/null &
                    disown
                fi
            ;;
            application/vnd.ms-excel|application/vnd.openxmlformats-officedocument.spreadsheetml.*)
                if [[ $os == "Windows" ]]; then
                    start excel "$file_path"
                elif [[ $os == "Mac" ]]; then
                    open -a "Microsoft Excel" "$file_path" &>/dev/null &
                else
                    nohup xdg-open "$file_path" &>/dev/null &
                    disown
                fi
            ;;
            application/vnd.ms-powerpoint|application/vnd.openxmlformats-officedocument.presentationml.*)
                if [[ $os == "Windows" ]]; then
                    start powerpnt "$file_path"
                elif [[ $os == "Mac" ]]; then
                    open -a "Microsoft PowerPoint" "$file_path" &>/dev/null &
                else
                    nohup xdg-open "$file_path" &>/dev/null &
                    disown
                fi
            ;;
            *)
                # Generic opener for all other types
                if [[ $os == "Windows" ]]; then
                    # 'start' is used to open files with their default applications on WIndows.
                    start "" "$file_path"
                elif [[ $os == "Mac" ]]; then
                    # 'open':   Open a file in the default application on Mac.
                    open "$file_path" &>/dev/null &
                else
                    # 'nohup':  Make the process immune to hangups.
                    # '&':      Send it to the background.
                    # 'disown': Detach it from the shell.
                    nohup "${FFF_OPENER:-${opener:-xdg-open}}" "$1" &>/dev/null &
                    disown
                fi
            ;;
        esac
    fi
}

cmd_line() {
    # Write to the command_line (under status_line).
    cmd_reply=

    # '\e7':     Save cursor position.
    # '\e[?25h': Unhide the cursor.
    # '\e[%sH':  Move cursor to bottom (cmd_line).
    printf '\e7\e[%sH\e[?25h' "$LINES"

    # '\r\e[K': Redraw the read prompt on every keypress.
    #           This is mimicking what happens normally.
    while IFS= read -rsn 1 -p $'\r\e[K'"${1}${cmd_reply}" read_reply; do
        case $read_reply in
            # Backspace.
            $'\177'|$'\b')
                cmd_reply=${cmd_reply%?}

                # Clear tab-completion.
                unset comp c
            ;;

            # Tab.
            $'\t')
                comp_glob="$cmd_reply*"

                # Pass the argument dirs to limit completion to directories.
                [[ $2 == dirs ]] &&
                    comp_glob="$cmd_reply*/"

                # Generate a completion list once.
                [[ -z ${comp[0]} ]] &&
                    IFS=$'\n' read -d "" -ra comp < <(compgen -G "$comp_glob")

                # On each tab press, cycle through the completion list.
                [[ -n ${comp[c]} ]] && {
                    cmd_reply=${comp[c]}
                    ((c=c >= ${#comp[@]}-1 ? 0 : ++c))
                }
            ;;

            # Escape / Custom 'no' value (used as a replacement for '-n 1').
            $'\e'|${3:-null})
                read "${read_flags[@]}" -rsn 2
                cmd_reply=
                break
            ;;

            # Enter/Return.
            "")
                # If there's only one search result and its a directory,
                # enter it on one enter keypress.
                [[ $2 == search && -d ${list[0]} ]] && ((list_total == 0)) && {
                    # '\e[?25l': Hide the cursor.
                    printf '\e[?25l'

                    open "${list[0]}"
                    search_end_early=1

                    # Unset tab completion variables since we're done.
                    unset comp c
                    return
                }

                break
            ;;

            # Custom 'yes' value (used as a replacement for '-n 1').
            ${2:-null})
                cmd_reply=$read_reply
                break
            ;;

            # Replace '~' with '$HOME'.
            "~")
                cmd_reply+=$HOME
            ;;

            # Anything else, add it to read reply.
            *)
                cmd_reply+=$read_reply

                # Clear tab-completion.
                unset comp c
            ;;
        esac

        # Search on keypress if search passed as an argument.
        [[ $2 == search ]] && {
            # '\e[?25l': Hide the cursor.
            printf '\e[?25l'

            if [[ $PWD == "HISTORY" ]]; then
                # Search in history mode
                list=()
                if [[ -n $cmd_reply ]]; then
                    for item in "${history_full_list[@]}"; do
                        if [[ $item == *"$cmd_reply"* ]]; then
                            list+=("$item")
                        fi
                    done
                else
                    list=("${history_full_list[@]}")
                fi
                ((list_total=${#list[@]}-1))
            else
                # Regular search
                # Use a greedy glob to search.
                list=("$PWD"/*"$cmd_reply"*)
                ((list_total=${#list[@]}-1))
            fi

            # Draw the search results on screen.
            scroll=0
            redraw

            # '\e[%sH':  Move cursor back to cmd-line.
            # '\e[?25h': Unhide the cursor.
            printf '\e[%sH\e[?25h' "$LINES"
        }
    done

    # Unset tab completion variables since we're done.
    unset comp c

    # '\e[2K':   Clear the entire cmd_line on finish.
    # '\e[?25l': Hide the cursor.
    # '\e8':     Restore cursor position.
    printf '\e[2K\e[?25l\e8'
}

extract() {
    # Extract an archive using 7-zip.

    if ! command -v 7z &>/dev/null; then
        status_line "Error: '7z' (7-Zip) is not installed."
        return
    fi

    # Extract an archive using 7-zip
    if [[ -f "${list[scroll]}" ]]; then
        archive_file="${list[scroll]}"
        archive_dir="${archive_file%.*}"

        # Get MIME type
        mime_type=$(file -b --mime-type -- "$archive_file")

        case "$mime_type" in
            application/zip|\
            application/x-7z-compressed|\
            application/x-rar|\
            application/x-rar-compressed|\
            application/x-tar|\
            application/gzip|\
            application/x-bzip2|\
            application/x-xz|\
            application/x-cab|\
            application/x-iso9660-image|\
            application/x-lzma|\
            application/x-rpm|\
            application/x-archive)
                mkdir -p "$archive_dir"
                7z x "$archive_file" -o"$archive_dir" > /dev/null 2>&1 &
                pid=$!

                while kill -0 "$pid" 2>/dev/null; do
                    status_line $'\e[37;40m Extracting '"${archive_file##*/}..."$'\e[0m'
                    sleep 1
                done

                status_line $'\e[37;40m Extraction complete: '"${archive_file##*/}"$'\e[0m'
                sleep 0.1
            ;;
            *)
                status_line "Error: Unsupported MIME type: $mime_type"
                sleep 0.1
                return
            ;;
        esac
        redraw full
    fi
}

archive() {
    # Archive a directory into a 7-zip archive.

    if ! command -v 7z &>/dev/null; then
        status_line "Error: '7z' (7-Zip) is not installed."
        return
    fi

    # Archive the selected directory into a 7-zip archive
    if [[ -d "${list[scroll]}" ]]; then
        cmd_line "Archive name: "
        [[ $cmd_reply ]] && {
            archive_name="${cmd_reply}.7z"
            if [[ -f "$archive_name" ]]; then
                status_line "Warning: '$archive_name' already exists."
                sleep 0.1
            elif [[ -w "$PWD" ]]; then
                7z a -mx=9 "$archive_name" "${list[scroll]}"/* > /dev/null 2>&1 &
                pid=$!

                while kill -0 "$pid" 2>/dev/null; do
                    status_line $'\e[37;40m Archiving to '"$archive_name..."$'\e[0m'
                    sleep 1
                done

                status_line $'\e[37;40m Archiving complete: '"$archive_name"$'\e[0m'
                sleep 0.1
            else
                status_line "Warning: No write access to directory."
                sleep 0.1
            fi
        }
        redraw full
    fi
}

key() {
    # Handle special key presses.
    [[ $1 == $'\e' ]] && {
        read "${read_flags[@]}" -rsn 2

        # Handle a normal escape key press.
        [[ ${1}${REPLY} == $'\e\e['* ]] &&
            read "${read_flags[@]}" -rsn 1 _

        local special_key=${1}${REPLY}
    }

    # Cancel repeat count or pending keys by pressing only Esc
    if [[ ${special_key} == $'\e' ]]; then
        repeat_count=""
        status_line $'\e[2K\r'  # Clear line
        redraw
        return
    fi

    # Accumulate numbers for vim-like motion
    if [[ -z $special_key && $1 =~ [0-9] ]]; then
        repeat_count=$(( repeat_count * 10 + $1 ))
        status_line $'\e[37;40m Line: '"$repeat_count " $'\e[0m'
        return
    fi

    # Handle vim-like motions with repeat count
    if [[ -n $repeat_count ]]; then
        local count=$((10#$repeat_count))  # Convert to decimal, ignore leading zeros
        repeat_count=""
        
        case ${special_key:-$1} in
            ${FFF_KEY_SCROLL_DOWN1:=j}|\
            ${FFF_KEY_SCROLL_DOWN2:=$'\e[B'}|\
            ${FFF_KEY_SCROLL_DOWN3:=$'\eOB'})
                ((new_scroll = scroll + count))
                ((new_scroll = new_scroll > list_total ? list_total : new_scroll))
                if ((new_scroll != scroll)); then
                    scroll=$new_scroll
                    redraw
                fi
                return
                ;;
                
            ${FFF_KEY_SCROLL_UP1:=k}|\
            ${FFF_KEY_SCROLL_UP2:=$'\e[A'}|\
            ${FFF_KEY_SCROLL_UP3:=$'\eOA'})
                ((new_scroll = scroll - count))
                ((new_scroll = new_scroll < 0 ? 0 : new_scroll))
                if ((new_scroll != scroll)); then
                    scroll=$new_scroll
                    redraw
                fi
                return
                ;;
        esac
    fi

    case ${special_key:-$1} in
        # Open list item.
        # 'C' is what bash sees when the right arrow is pressed
        # ('\e[C' or '\eOC').
        # '' is what bash sees when the enter/return key is pressed.
        ${FFF_KEY_CHILD1:=l}|\
        ${FFF_KEY_CHILD2:=$'\e[C'}|\
        ${FFF_KEY_CHILD3:=""}|\
        ${FFF_KEY_CHILD4:=$'\eOC'})
            open "${list[scroll]}"
        ;;

        # Go to the parent directory.
        # 'D' is what bash sees when the left arrow is pressed
        # ('\e[D' or '\eOD').
        # '\177' and '\b' are what bash sometimes sees when the backspace
        # key is pressed.
        ${FFF_KEY_PARENT1:=h}|\
        ${FFF_KEY_PARENT2:=$'\e[D'}|\
        ${FFF_KEY_PARENT3:=$'\177'}|\
        ${FFF_KEY_PARENT4:=$'\b'}|\
        ${FFF_KEY_PARENT5:=$'\eOD'})
            # Exit history mode if active
            if ((history_mode == 1)); then
                # Restore saved state from before history mode
                PWD=$saved_PWD
                history_mode=0
                redraw full
            # If a search was done, clear the results and open the current dir.
            elif ((search == 1 && search_end_early != 1)); then
                open "$PWD"

            # If '$PWD' is '/', do nothing.
            elif [[ $PWD && $PWD != / ]]; then
                find_previous=1
                open "${PWD%/*}"
            fi
        ;;

        # Scroll down.
        # 'B' is what bash sees when the down arrow is pressed
        # ('\e[B' or '\eOB').
        ${FFF_KEY_SCROLL_DOWN1:=j}|\
        ${FFF_KEY_SCROLL_DOWN2:=$'\e[B'}|\
        ${FFF_KEY_SCROLL_DOWN3:=$'\eOB'})
            ((scroll < list_total)) && {
                ((scroll++))
                ((y < max_items)) && ((y++))

                if ((scroll == list_total)); then
                    # full redraw when reaching last item
                    redraw
                else
                    print_line "$((scroll - 1))"
                    printf '\n'
                    print_line "$scroll"
                    status_line
                    redraw_numbers
                fi
            }
        ;;

        # Scroll up.
        # 'A' is what bash sees when the up arrow is pressed
        # ('\e[A' or '\eOA').
        ${FFF_KEY_SCROLL_UP1:=k}|\
        ${FFF_KEY_SCROLL_UP2:=$'\e[A'}|\
        ${FFF_KEY_SCROLL_UP3:=$'\eOA'})
            # '\e[1L': Insert a line above the cursor.
            # '\e[A':  Move cursor up a line.
            ((scroll > 0)) && {
                ((scroll--))

                if ((scroll <= 0)); then
                    # full redraw near top
                    redraw
                else
                    print_line "$((scroll + 1))"

                    if ((y < 2)); then
                        printf '\e[L'
                    else
                        printf '\e[A'
                        ((y--))
                    fi

                    print_line "$scroll"
                    status_line
                    redraw_numbers
                fi
            }
        ;;

        # Go to top.
        ${FFF_KEY_TO_TOP:=g})
            ((scroll != 0)) && {
                scroll=0
                redraw
            }
        ;;

        # Go to bottom.
        ${FFF_KEY_TO_BOTTOM:=G})
            ((scroll != list_total)) && {
                ((scroll=list_total))
                redraw
            }
        ;;

        # Show hidden files.
        ${FFF_KEY_HIDDEN:=.})
            # 'a=a>0?0:++a': Toggle between both values of 'shopt_flags'.
            #                This also works for '3' or more values with
            #                some modification.
            shopt_flags=(u s)
            shopt -"${shopt_flags[((a=${a:=$FFF_HIDDEN}>0?0:++a))]}" dotglob
            redraw full
        ;;

        # Search.
        ${FFF_KEY_SEARCH:=/})
            cmd_line "/" "search"

            # If the search came up empty, redraw the current dir.
            if [[ -z ${list[*]} ]]; then
                list=("${cur_list[@]}")
                ((list_total=${#list[@]}-1))
                redraw
                search=
            else
                search=1
            fi
        ;;

        # Spawn a shell.
        ${FFF_KEY_SHELL:=!})
            reset_terminal

            # Make fff aware of how many times it is nested.
            export FFF_LEVEL
            ((FFF_LEVEL++))

            cd "$PWD" && "$SHELL"
            setup_terminal
            redraw full
        ;;

        # Mark files for operation.
        ${FFF_KEY_YANK:=y}|\
        ${FFF_KEY_MOVE:=m}|\
        ${FFF_KEY_TRASH:=d}|\
        ${FFF_KEY_LINK:=s}|\
        ${FFF_KEY_BULK_RENAME:=b})
            mark "$scroll" "$1"
            redraw_numbers
        ;;

        # Mark all files for operation.
        ${FFF_KEY_YANK_ALL:=Y}|\
        ${FFF_KEY_MOVE_ALL:=M}|\
        ${FFF_KEY_TRASH_ALL:=D}|\
        ${FFF_KEY_LINK_ALL:=S}|\
        ${FFF_KEY_BULK_RENAME_ALL:=B})
            mark all "$1"
            redraw_numbers
        ;;

        # Do the file operation.
        ${FFF_KEY_PASTE:=p})
            [[ ${marked_files[*]} ]] && {
                [[ ! -w $PWD ]] && {
                    cmd_line "warn: no write access to dir."
                    return
                }

                # Clear the screen to make room for a prompt if needed.
                clear_screen
                reset_terminal

                stty echo
                printf '\e[1mfff\e[m: %s\n' "Running ${file_program[0]}"
                "${file_program[@]}" "${marked_files[@]}" .
                stty -echo

                marked_files=()
                setup_terminal
                redraw full
            }
        ;;

        # Clear all marked files.
        ${FFF_KEY_CLEAR:=c})
            [[ ${marked_files[*]} ]] && {
                marked_files=()
                redraw
            }
        ;;

        # Rename list item.
        ${FFF_KEY_RENAME:=r})
            [[ ! -e ${list[scroll]} ]] &&
                return

            cmd_line "rename ${list[scroll]##*/}: "

            [[ $cmd_reply ]] &&
                if [[ -e $cmd_reply ]]; then
                    cmd_line "warn: '$cmd_reply' already exists."

                elif [[ -w ${list[scroll]} ]]; then
                    mv "${list[scroll]}" "${PWD}/${cmd_reply}"
                    redraw full

                else
                    cmd_line "warn: no write access to file."
                fi
        ;;

        # Create a directory.
        ${FFF_KEY_MKDIR:=n})
            cmd_line "mkdir: " "dirs"

            [[ $cmd_reply ]] &&
                if [[ -e $cmd_reply ]]; then
                    cmd_line "warn: '$cmd_reply' already exists."

                elif [[ -w $PWD ]]; then
                    mkdir -p "${PWD}/${cmd_reply}"
                    redraw full

                else
                    cmd_line "warn: no write access to dir."
                fi
        ;;

        # Create a file.
        ${FFF_KEY_MKFILE:=f})
            cmd_line "mkfile: "

            [[ $cmd_reply ]] &&
                if [[ -e $cmd_reply ]]; then
                    cmd_line "warn: '$cmd_reply' already exists."

                elif [[ -w $PWD ]]; then
                    : > "$cmd_reply"
                    redraw full

                else
                    cmd_line "warn: no write access to dir."
                fi
        ;;

        # Show file attributes in human-readable format
        ${FFF_KEY_ATTRIBUTES:=x})
            [[ -e "${list[scroll]}" ]] && {
                clear_screen
                status_line "${list[scroll]}"
                stat_output=$("${FFF_STAT_CMD:-stat}" "${list[scroll]}")
                file_size=$(awk '/Size:/ {print $2}' <<< "$stat_output")
                human_readable_size=$(numfmt --to=iec-i --suffix=B --format='%3.1f' <<< "$file_size")
                echo "$stat_output"
                echo "Human-readable size: $human_readable_size"
                read -ern 1
                redraw
            }
        ;;

        # Toggle executable flag.
        ${FFF_KEY_EXECUTABLE:=X})
            [[ -f ${list[scroll]} && -w ${list[scroll]} ]] && {
                if [[ -x ${list[scroll]} ]]; then
                    chmod -x "${list[scroll]}"
                    status_line "Unset executable."
                else
                    chmod +x "${list[scroll]}"
                    status_line "Set executable."
                fi
            }
        ;;

        # Show image in terminal.
        ${FFF_KEY_IMAGE:=i})
            draw_img
        ;;

        # Save directory to go back later
        ${FFF_KEY_SAVE_DIR:="'"})
            if [[ -z "$saved_dir1" ]]; then
                saved_dir1="$PWD"
                status_line "Directory 1 saved: $saved_dir1"
            elif [[ -z "$saved_dir2" ]]; then
                saved_dir2="$PWD"
                status_line "Directory 2 saved: $saved_dir2"
            else
                saved_dir1=""
                saved_dir2=""
                status_line "Saved directories cleared"
            fi
        ;;

        # Go to saved directory or last directory
        ${FFF_KEY_GO_SAVED_DIR:=';'})
            if [[ -n "$saved_dir1" && -n "$saved_dir2" ]]; then
                # Flip-flop between the two saved directories
                if [[ "$PWD" == "$saved_dir1" ]]; then
                    open "$saved_dir2"
                else
                    open "$saved_dir1"
                fi
            elif [[ -n "$saved_dir1" ]]; then
                open "$saved_dir1"
            elif [[ -n "$saved_dir2" ]]; then
                open "$saved_dir2"
            else
                # No saved directories, do nothing
                :
            fi
        ;;

        # Go to dir.
        ${FFF_KEY_GO_DIR:=:})
            cmd_line "go to dir: " "dirs"

            # Let 'cd' know about the current directory.
            cd "$PWD" &>/dev/null ||:

            [[ $cmd_reply ]] &&
                cd "${cmd_reply/\~/$HOME}" &>/dev/null &&
                    open "$PWD"
        ;;

        # Go to '$HOME'.
        ${FFF_KEY_GO_HOME:='~'})
            open ~
        ;;

        # Go to trash.
        ${FFF_KEY_GO_TRASH:=t})
            get_os
            open "$FFF_TRASH"
        ;;

        # Go to previous dir.
        ${FFF_KEY_PREVIOUS:=-})
            open "$OLDPWD"
        ;;

        # Refresh current dir.
        ${FFF_KEY_REFRESH:=e})
            open "$PWD"
        ;;

        # Show history
        ${FFF_KEY_HISTORY:='H'})
            show_history
        ;;

        # Extract an archive
        ${FFF_KEY_EXTRACT:=z})
            extract
        ;;

        # Archive the current directory
        ${FFF_KEY_ARCHIVE:=Z})
            archive
        ;;

        # Quit and store current directory in a file for CD on exit.
        # Don't allow user to redefine 'q' so a bad keybinding doesn't
        # remove the option to quit.
        q)
            : "${FFF_CD_FILE:=${XDG_CACHE_HOME:=${HOME}/.cache}/fff/.fff_d}"

            [[ -w $FFF_CD_FILE ]] &&
                rm "$FFF_CD_FILE"

            [[ ${FFF_CD_ON_EXIT:=1} == 1 ]] &&
                printf '%s\n' "$PWD" > "$FFF_CD_FILE"

            exit
        ;;
    esac
}

main() {
    # Handle a directory as the first argument.
    # 'cd' is a cheap way of finding the full path to a directory.
    # It updates the '$PWD' variable on successful execution.
    # It handles relative paths as well as '../../../'.
    #
    # '||:': Do nothing if 'cd' fails. We don't care.
    cd "${2:-$1}" &>/dev/null ||:

    [[ $1 == -v ]] && {
        printf '%s\n' "fff 2.2"
        exit
    }

    [[ $1 == -h ]] && {
        man fff
        exit
    }

    # Store file name in a file on open instead of using 'FFF_OPENER'.
    # Used in 'fff.vim'.
    [[ $1 == -p ]] &&
        file_picker=1

    # bash 5 and some versions of bash 4 don't allow SIGWINCH to interrupt
    # a 'read' command and instead wait for it to complete. In this case it
    # causes the window to not redraw on resize until the user has pressed
    # a key (causing the read to finish). This sets a read timeout on the
    # affected versions of bash.
    # NOTE: This shouldn't affect idle performance as the loop doesn't do
    # anything until a key is pressed.
    # SEE: https://github.com/dylanaraps/fff/issues/48
    ((BASH_VERSINFO[0] > 3)) &&
        read_flags=(-t 0.05)

    ((${FFF_LS_COLORS:=1} == 1)) &&
        get_ls_colors

    ((${FFF_HIDDEN:=0} == 1)) &&
        shopt -s dotglob

    # Create the trash and cache directory if they don't exist.
    mkdir -p "${XDG_CACHE_HOME:=${HOME}/.cache}/fff" \
             "${FFF_TRASH:=${XDG_DATA_HOME:=${HOME}/.local/share}/fff/trash}"

    # 'nocaseglob': Glob case insensitively (Used for case insensitive search).
    # 'nullglob':   Don't expand non-matching globs to themselves.
    shopt -s nocaseglob nullglob

    # Trap the exit signal (we need to reset the terminal to a useable state.)
    trap 'reset_terminal' EXIT

    # Trap the window resize signal (handle window resize events).
    trap 'get_term_size; redraw' WINCH

    get_os
    get_term_size
    setup_options
    setup_terminal
    redraw full

    # Vintage infinite loop.
    for ((;;)); {
        read "${read_flags[@]}" -srn 1 && key "$REPLY"

        # Exit if there is no longer a terminal attached.
        [[ -t 1 ]] || exit 1
    }
}

main "$@"
